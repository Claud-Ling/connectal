This is an experimental ring-style interface between
software and hardware.

L. Stewart
12/10/2013

The idea is to let sw and hw proceed independently, at times with
either running faster.

Commands are placed in an outbound ring buffer.
Incoming events also arrive in a ring.
Objects in a ring are fixed size: ITEM

Each ring is described by four hardware register values: base, end, first, and last.

Call end-base SIZE

A ring is empty when first == last
A ring is full when (last + ITEM + SIZE) % SIZE == first

Initialization

Software writes base, end, first, last, for the command and status rings,
and then enables the hardware engine

Writing Commands

Software should already know how much space is available in the command ring.

Software writes new commands starting at first, then writes a new value into
first.

When hardware notices that last != first, it starts processing commands at last.
After each command, hardware updates last.

Software must assure that there is always space in the status ring.
In order to avoid unneccesary polling of the status ring pointers, software
can poll the first word of the next unread status item.  This will become
non-zero when hardware writes the entry

[what are the atomic properties of pci writes? when do these status entries
become visible to hardware?  Maybe the first word should have three
states: idle, next, and done.  Packet n is finished when the status word
for word n+1 transitions from idle to next, or something.]

Commands

MARK
tag

Copies command to status ring

NOP
Does nothing

REPORTC
tag

returns tag, base, end, first, last of command ring

REPORTS
tag

returns tag, base, end, first, last of status ring


Requests


