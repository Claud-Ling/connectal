#!/usr/bin/python
## Copyright (c) 2013-2014 Quanta Research Cambridge, Inc.

## Permission is hereby granted, free of charge, to any person
## obtaining a copy of this software and associated documentation
## files (the "Software"), to deal in the Software without
## restriction, including without limitation the rights to use, copy,
## modify, merge, publish, distribute, sublicense, and/or sell copies
## of the Software, and to permit persons to whom the Software is
## furnished to do so, subject to the following conditions:

## The above copyright notice and this permission notice shall be
## included in all copies or substantial portions of the Software.

## THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
## EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
## MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
## NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
## BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
## ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
## CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
## SOFTWARE.

import os, sys, shutil, string
import AST
import bsvgen
import xpsgen
import cppgen
import syntax
import argparse
import subprocess
import util
import re
import glob
import time
#import functools
#import math

AST.TypeDef.__bases__ += (cppgen.TypeDefMixin,)
AST.Function.__bases__ += (cppgen.NoCMixin,)
AST.Module.__bases__ += (cppgen.NoCMixin,)
AST.Method.__bases__ += (cppgen.MethodMixin,bsvgen.MethodMixin)
AST.StructMember.__bases__ += (cppgen.StructMemberMixin,)
AST.Struct.__bases__ += (cppgen.StructMixin,bsvgen.NullMixin)
AST.EnumElement.__bases__ += (cppgen.EnumElementMixin,)
AST.Enum.__bases__ += (cppgen.EnumMixin,bsvgen.EnumMixin)
AST.Type.__bases__ += (cppgen.TypeMixin,bsvgen.TypeMixin)
AST.Param.__bases__ += (cppgen.ParamMixin,bsvgen.ParamMixin)
AST.Interface.__bases__ += (cppgen.InterfaceMixin,bsvgen.InterfaceMixin)

supported_boards = ['ac701', 'zedboard', 'zc702', 'zc706', 'kc705', 'vc707', 'zynq100', 'v2000t', 'bluesim']
supported_os = ['android', 'ubuntu']

argparser = argparse.ArgumentParser("Generate C++/BSV/Xilinx stubs for an interface.")
argparser.add_argument('bsvfile', help='BSV files to parse', nargs='+')
argparser.add_argument('-B', '--board', default='zc702', choices=supported_boards,
                       help='Board to generate stubs and ucf constraints for')
argparser.add_argument('-O', '--OS', default=None, choices=supported_os,
                       help='Target operating system')
argparser.add_argument('-s2h', '--s2hinterface', help='BSV interface to generate stubs for software to hardware communication', action='append')
argparser.add_argument('-h2s', '--h2sinterface', help='BSV interface to generate stubs for hardware to software communication', action='append')
argparser.add_argument('-p', '--project-dir', default='./xpsproj', help='xps project directory')
argparser.add_argument('-e', '--edk-version', default=xpsgen.edkversion, help='Xilinx EDK version', choices=xpsgen.edkversions)
argparser.add_argument('-s', '--source', help='C++ source files', action='append')
argparser.add_argument(      '--contentid', help='Specify 64-bit contentid for PCIe designs')
argparser.add_argument('-I', '--cinclude', help='Specify C++ include directories', default=[], action='append')
argparser.add_argument('-V', '--verilog', default=[], help='Additional verilog sources', action='append')
argparser.add_argument('--xci', default=[], help='Additional IP sources', action='append')
argparser.add_argument('-C', '--constraint', help='Additional constraint files', action='append')
argparser.add_argument('-M', '--make', help='Run make on the specified targets', action='append')
argparser.add_argument('-x', '--export', help='Promote/export named interface from top module')
argparser.add_argument('-t', '--topbsv', help='Top-level bsv file')
argparser.add_argument('-D', '--bsvdefine', default=[], help='BSV define', action='append')
argparser.add_argument('-l', '--clib', default=[], help='C++ libary', action='append')
argparser.add_argument('-S', '--clibfiles', default=[], help='C++ libary file', action='append')
argparser.add_argument('-L', '--clibdir', default=[], help='C++ libary', action='append')
argparser.add_argument('-T', '--tcl', default=[], help='Vivado tcl script', action='append')
argparser.add_argument('-m', '--bsimsource', help='Bsim C++ source files', action='append')
argparser.add_argument('-b', '--bscflags', default=[], help='Options to pass to the BSV compiler', action='append')
argparser.add_argument('--xelabflags', default=[], help='Options to pass to the xelab compiler', action='append')
argparser.add_argument('--xsimflags', default=[], help='Options to pass to the xsim simulator', action='append')
argparser.add_argument('--ipdir', help='Directory in which to store generated IP')
argparser.add_argument('-q', '--qtused', help='Qt used in Bsim test application', action='store_true')
argparser.add_argument('--stl', help='STL implementation to use for Android builds', default=None)
argparser.add_argument('--floorplan', help='Floorplan XDC', default=None)
argparser.add_argument('-P', '--partition-module', default=[], help='Modules to separately synthesize/place/route', action='append')
argparser.add_argument('--cachedir', default=None, help='Cache directory for fpgamake to use')
argparser.add_argument('-v', '--verbose', help='Display verbose information messages', action='store_true')

noisyFlag=False

tclReadVerilogTemplate='read_verilog [ glob %(verilog)s%(pattern)s ]'
tclReadXciTemplate='''
generate_target {Synthesis} [get_files %(xci)s]
read_ip %(xci)s
'''

tclfileConstraintTemplate='''read_xdc {./constraints/%(xdcname)s}'''

tclboardTemplate='''
set partname {%(partname)s}
set boardname {%(boardname)s}
set xbsvdir {%(xbsvdir)s}
set xbsvipdir {%(ipdir)s}
set needspcie {%(needspcie)s}
%(tcldefines)s
'''

tclfileTemplate='''
# NOTE: typical usage would be "vivado -mode tcl -source create_mkPcieTop_batch.tcl" 
#
# STEP#0: define output directory area.
#
set outputDir ./hw
file mkdir $outputDir
#
# STEP#1: setup design sources and constraints
#
source board.tcl
source $xbsvdir/scripts/xilinx/tcl/log.tcl

####Report and DCP controls - values: 0-required min; 1-few extra; 2-all
set verbose      2
set dcpLevel     1

### logs
set runLog "run"
set commandLog "command"
set criticalLog "critical"
set logs [list $runLog $commandLog $criticalLog]
set rfh [open "$runLog.log" w]
set cfh [open "$commandLog.log" w]
set wfh [open "$criticalLog.log" w]

create_project -in_memory -part $partname
read_verilog [ glob {verilog/*.v} ]
%(read_verilog)s
%(read_xci)s
%(tclfileConstraints)s

source $xbsvdir/scripts/xbsv-synth-ip.tcl

if [file exists ../synth-ip.tcl] {
    source ../synth-ip.tcl
}

# STEP#2: run synthesis, report utilization and timing estimates, write checkpoint design
#
command "synth_design -name %(Dut)s -top %(Dut)s -part %(partname)s -flatten rebuilt" hw/synth_design.log

write_checkpoint -force $outputDir/top-post-synth > hw/temp.log
#not in 2013.2 report_timing_summary -warn_on_violation
#not in 2013.2 report_timing_summary -warn_on_violation -verbose  -file $outputDir/top-post-synth-timing-summary.rpt > hw/temp.log
report_timing -nworst 20 -sort_by slack -path_type summary -slack_lesser_than 0.2 -unique_pins
report_io -file $outputDir/top-post-synth-io.rpt > hw/temp.log
puts "****************************************"
puts "If timing report says 'No timing paths found.' then the design met the timing constraints."
puts "If it reported negative slack, then the design did not meet the timing constraints."
puts "****************************************"
report_timing_summary -verbose  -file $outputDir/top-post-synth-timing-summary.rpt > hw/temp.log
report_timing -sort_by group -max_paths 100 -path_type summary -file $outputDir/top-post-synth-timing.rpt > hw/temp.log
report_utilization -verbose -file $outputDir/top-post-synth-utilization.txt > hw/temp.log
report_datasheet -file $outputDir/top-post-synth_datasheet.txt > hw/temp.log
write_verilog -force $outputDir/top-netlist.v > hw/temp.log
#report_power -file $outputDir/top-post-synth-power.rpt

#
# STEP#3: run placement and logic optimization, report utilization and timing estimates, write checkpoint design
#
%(sourceTcl)s
%(rewire_clock)s
command opt_design     hw/opt_design.log
write_checkpoint -force $outputDir/top-post-opt.dcp > hw/temp.log

# power_opt_design
command place_design    hw/place_design.log
report_timing_summary -file $outputDir/top-post-place-timing-summary.rpt > hw/temp.log
report_timing -nworst 20 -sort_by slack -path_type summary -slack_lesser_than 0.2 -unique_pins
report_io -file $outputDir/top-post-place-io.rpt > hw/temp.log
write_checkpoint -force $outputDir/top-post-place > hw/temp.log
command phys_opt_design hw/phys_opt_design.log
report_timing_summary -file $outputDir/top-post-phys-opt-timing-summary.rpt > hw/temp.log
report_timing -nworst 20 -sort_by slack -path_type summary -slack_lesser_than 0.2 -unique_pins
write_checkpoint -force $outputDir/top-post-phys-opt > hw/temp.log
#not in 2013.2 report_timing_summary -warn_on_violation -file $outputDir/top-post-place-timing-summary.rpt > hw/temp.log
#
# STEP#4: run router, report actual utilization and timing, write checkpoint design, run drc, write verilog and xdc out
#
command route_design hw/route_design.log
write_checkpoint -force $outputDir/top-post-route > hw/temp.log
#not in 2013.2 report_timing_summary -warn_on_violation
#not in 2013.2 report_timing_summary -warn_on_violation -file $outputDir/top-post-route-timing-summary.rpt > hw/temp.log
report_timing -nworst 20 -sort_by slack -path_type summary -slack_lesser_than 0.2 -unique_pins
puts "****************************************"
puts "If timing report says 'No timing paths found.' then the design met the timing constraints."
puts "If it reported negative slack, then the design did not meet the timing constraints."
puts "****************************************"
report_timing_summary -file $outputDir/top-post-route-timing-summary.rpt > hw/temp.log
report_timing -sort_by group -max_paths 100 -path_type summary -file $outputDir/top-post-route-timing.rpt > hw/temp.log
report_clock_utilization -file $outputDir/top-clock-util.rpt > hw/temp.log
report_utilization -file $outputDir/top-post-route-util.rpt > hw/temp.log
report_datasheet -file $outputDir/top-post-route_datasheet.rpt > hw/temp.log
report_io -file $outputDir/top-post-route-io.rpt > hw/temp.log
#report_power -file $outputDir/top-post-route-power.rpt
#report_drc -file $outputDir/top-post-imp-drc.rpt
#write_verilog -force $outputDir/top-impl_netlist.v
write_xdc -no_fixed_only -force $outputDir/top-impl.xdc > hw/temp.log

## Halt the flow with an error if the timing constraints weren't met
## (thanks to http://xillybus.com/tutorials/vivado-timing-constraints-error for this way to do it)
set minireport [report_timing_summary -no_header -no_detailed_paths -return_string]
if {! [string match -nocase {*timing constraints are met*} $minireport]} {
#    send_msg_id showstopper-0 error "Timing constraints weren't met. Please check your design."
#    return -code error
   puts "Error: Timing constraints weren't met. Please check your design."
}

#
# STEP#5: generate a bitstream
# 
set_property SEVERITY {Warning} [get_drc_checks NSTD-1]
set_property SEVERITY {Warning} [get_drc_checks UCIO-1]
report_drc -file $outputDir/top-post-route-drc.rpt > hw/temp.log
write_bitstream -force -bin_file $outputDir/mkTop.bit

close $rfh
close $cfh
close $wfh
'''

tclzynqrewireclock = '''
foreach {pat} {CLK_GATE_hdmi_clock_if CLK_*deleteme_unused_clock* CLK_GATE_*deleteme_unused_clock* RST_N_*deleteme_unused_reset*} {
    foreach {net} [get_nets -quiet $pat] {
        puts "disconnecting net $net"
	disconnect_net -net $net -objects [get_pins -quiet -of_objects $net]
    }
}
'''

bitsmakeRuleTemplate='''
hw/mkTop.bit: $(vfile)
	vivado -mode batch -source vivado-impl.tcl $(VIVADOFLAGS)
	mkdir -p bin
	cp -f hw/*.rpt bin
'''

fpgamakeRuleTemplate='''
FPGAMAKE=$(XBSVDIR)/../fpgamake/fpgamake
fpgamake.mk: $(vfile) Makefile
	mkdir -p hw
	$(FPGAMAKE) -o fpgamake.mk %(partitions)s --floorplan=%(floorplan)s %(xdc)s %(xci)s -t $(MKTOP) %(cachedir)s -b hw/mkTop.bit verilog $(XBSVDIR)/verilog

hw/mkTop.bit: fpgamake.mk
	make -f fpgamake.mk
	mkdir -p bin
	cp -f Impl/*/*.rpt bin
'''

makefileTemplate='''
## make targets
##    all: make software and programmable logic binaries
##    run: run the program
##         pass parameters to software via 'make RUN_ARGS= run'
RUN_ARGS=

V=0
ifeq ($(V),0)
Q=@
BSC_QUIET=-no-show-compiles
XBSV_NDK_PARAM="NDK_HOST_ECHO=true"
else
Q=
BSC_QUIET=
XBSV_NDK_PARAM=
endif

DTOP=%(project_dir)s
XBSVDIR=%(xbsvdir)s
BSVPATH = %(bsvpath)s
vfile=verilog/%(topbsvmod)s.v

BOARD=%(boardname)s
MKTOP=%(topbsvmod)s
OS=%(OS)s
ifeq ($(BOARD),bluesim)
    ALLTARGETS=bsim bsim_exe
else
  ifeq ($(OS),android)
    ALLTARGETS=android_exe%(debug)s bits
  else
    ALLTARGETS=ubuntu_exe bits
  endif
endif

BSCMAJOR=%(bscmajor)d
ifneq ($(BSCMAJOR), 2013)
    # S0015: The use of a mkSyncReset may not always result in a reset
    #        signal being seen on the destination side. Recommend
    #        replacement with mkAsyncReset.
    BSCWARNFLAGS += -demote-errors G0066:G0045 -suppress-warnings G0046:G0020:S0015
endif
BSCOPTFLAGS= -show-schedule -aggressive-conditions
BSCPATHFLAGS=  -bdir $(DTOP)/obj -vdir $(DTOP)/verilog -simdir $(DTOP)/obj -info-dir $(DTOP)/obj
BSCFLAGS = $(BSCWARNFLAGS) $(BSCOPTFLAGS) $(BSCPATHFLAGS) --wait-for-license -D TimeStamp=%(timestamp)s %(bscflags)s
BSIM_CXX = $(XBSVDIR)/cpp/BsimCtrl.cxx $(XBSVDIR)/cpp/TlpReplay.cxx $(XBSVDIR)/cpp/BsimDma.cxx $(XBSVDIR)/cpp/sock_utils.c %(bsimsource)s

VIVADOFLAGS= -notrace
XVLOGFLAGS =
XELABFLAGS = %(xelabflags)s
XSIMFLAGS  = %(xsimflags)s

%(mdefines)s

all: $(ALLTARGETS)

S2H = %(s2hinterface)s
H2S = %(h2sinterface)s
BSVFILES = %(bsvfiles)s
CPPFILES=%(sourcefiles)s $(addprefix %(project_dir)s/jni/, %(generatedCFiles)s)

timestampfile=sources/%(dut)s/.timestamp

$(timestampfile): %(bsvfiles)s
	cd $(DTOP); \
	$(XBSVDIR)/xbsvgen -B$(BOARD) -p %(project_dir)s -x $(MKTOP) \
	$(foreach s2h, $(S2H), -s2h $(s2h)) \
	$(foreach h2s, $(H2S), -h2s $(h2s)) \
	$(foreach f, $(CPPFILES), -s $f) \
        -t $(XBSVDIR)/bsv/$(TOP).bsv $(XBSVFLAGS) $(BSVFILES)
	touch $(timestampfile)

$(vfile): %(topbsvfile)s %(bsvfiles)s $(timestampefile)
	mkdir -p verilog/portal $(DTOP)/obj
	cd sources/%(dut)s; bsc $(BSC_QUIET) %(bsvdefines)s $(BSCFLAGS) -remove-dollar -p +:$(DTOP)/generatedbsv:$(BSVPATH) -verilog -u -g %(topbsvmod)s %(topbsvfile)s
	sed -i 's|// On .*|// timestamp removed|' verilog/*.v
	for v in verilog/*.v; do $(XBSVDIR)/scripts/copy_verilog.py $$v $(subst :, ,$(BSVPATH)); done

bsim_exe:
	@mkdir -p bin
	@git rev-parse HEAD > bin/githash
	@git diff | gzip -c > bin/gitdiff.patch.gz
	$(Q)cd jni; make --no-print-directory -f Ubuntu.mk bsim_exe
	@cp -v jni/bsim_exe bin

ubuntu_exe:
	@mkdir -p bin
	@git rev-parse HEAD > bin/githash
	@git diff | gzip -c > bin/gitdiff.patch.gz
	$(Q)cd jni; make --no-print-directory -f Ubuntu.mk
	@cp -v jni/mk* bin

bsim: $(timestampfile)
	@mkdir -p bin
	@git rev-parse HEAD > bin/githash
	@git diff | gzip -c > bin/gitdiff.patch.gz
	mkdir -p $(DTOP)/obj
	cd sources; bsc $(BSC_QUIET) -D BSIM %(bsvdefines)s $(BSCFLAGS) -p +:$(BSVPATH):%(dut)s/ -sim -u -g %(topbsvmod)s %(topbsvfile)s
	export BSC_CXXFLAGS="-I$(XBSVDIR)/cpp -I$(XBSVDIR) -DBSIM" ; cd sources; bsc $(BSC_QUIET) $(BSCFLAGS) -p +:$(BSVPATH):%(dut)s/ -sim -e $(MKTOP) -o bsim $(DTOP)/obj/*.ba $(BSIM_CXX)
	@cp -v sources/bsim* bin
	%(qtused)s

verilog: $(vfile)

lint: $(vfile)
	verilator --error-limit 200 --lint-only -Isources/%(dut)s -Isources/source $(vfile)

%(bitsmake)s

implementation: bits

program:
	fpgajtag bin/mkTop.bin.gz
	sleep 1

reprogram:
	vivado -mode batch -source top-reprogram.tcl $(VIVADOFLAGS)
	xbsvutil reset /dev/fpga0

## for partial reconfiguration on VC707
verilog/portal/mkSynthesizeablePortalTop.v:
	mkdir -p verilog/portal
	mv -fv verilog/mkSynthesizeablePortalTop.v verilog/portal

## (*black_box*) causes vivado to ignore contents of the module and treat it as a black box
verilog/portalstub.v:
	make --no-print-directory verilog/portal/mkSynthesizeablePortalTop.v
	cat verilog/portal/mkSynthesizeablePortalTop.v | sed 's/^module /(*black_box*)module /' > verilog/portalstub.v

hw/portaltop-post-synth.dcp: verilog/portal/mkSynthesizeablePortalTop.v $(vfile)
	make --no-print-directory verilog/portalstub.v
	vivado -mode batch -source $(XBSVDIR)/scripts/portaltop-synth.tcl $(VIVADOFLAGS)

hw/mkpcietop-post-synth.dcp:
	make --no-print-directory verilog/portalstub.v
	vivado -mode batch -source $(XBSVDIR)/scripts/mkpcietop-synth.tcl $(VIVADOFLAGS)

hw/mkPcieTop_pblock_portalTop_partial.bit: hw/mkpcietop-post-synth.dcp hw/portaltop-post-synth.dcp
	vivado -mode batch -source $(XBSVDIR)/scripts/mkpcietop-partial-reconfiguration.tcl $(VIVADOFLAGS)

partial: hw/mkPcieTop_pblock_portalTop_partial.bit

.PHONY: bits

ifeq ($(OS),android)

bits: hw/mkTop.bit
	@mkdir -p bin
	@git rev-parse HEAD > bin/githash
	@git diff | gzip -c > bin/gitdiff.patch.gz
	xxd hw/mkTop.bin | sed -e "s/  .*//" -e "s/ \(..\)\(..\) \(..\)\(..\)/ \\4\\3 \\2\\1/g" | xxd -r > bin/mkTop.xdevcfg.bin
	gzip -f bin/mkTop.xdevcfg.bin
	$(XBSVDIR)/scripts/check-timing.py bin/top-post-route-timing-summary.rpt

else

bits: hw/mkTop.bit
	@mkdir -p bin
	@git rev-parse HEAD > bin/githash
	@git diff | gzip -c > bin/gitdiff.patch.gz
	gzip -c hw/mkTop.bin > bin/mkTop.bin.gz
	$(XBSVDIR)/scripts/check-timing.py bin/top-post-route-timing-summary.rpt

endif

android_exe:
	@mkdir -p bin
	@git rev-parse HEAD > bin/githash
	@git diff | gzip -c > bin/gitdiff.patch.gz
	ndk-build $(XBSV_NDK_PARAM)
	@cp -v libs/armeabi/android_exe bin

android_exe_debug:
	@mkdir -p bin
	@git rev-parse HEAD > bin/githash
	@git diff | gzip -c > bin/gitdiff.patch.gz
	ndk-build $(XBSV_NDK_PARAM) -B V=1 NDK_DEBUG=1
	@cp -v libs/armeabi/android_exe bin

ifeq ($(BOARD),bluesim)

ifeq ($(XBSV_DEBUG),1)
GDB=gdb
else
GDB=
endif

run:
	./bin/bsim& bsimpid=$$!; echo bsimpid $$bsimpid; $(GDB) ./bin/bsim_exe $(RUN_ARGS); retcode=$$?; kill $$bsimpid; exit $$retcode

else

    ifeq ($(OS),android)

run:
	$(XBSVDIR)/scripts/run.zedboard bin/mkTop.xdevcfg.bin.gz bin/android_exe $(RUN_ARGS)

    else

run: program
	timeout 3m catchsegv ./bin/mkpcietop $(RUN_ARGS)

    endif
endif

xsim: verilog
	xvlog $(XVLOGFLAGS) verilog/*.v
	xelab $(XELABFLAGS) work.$(MKTOP)

xsimrun: xsim
	xsim $(XSIMFLAGS) work.$(MKTOP)

JENKINS_HOST=sj9.qrclab.com
jenkins:
	$(XBSVDIR)/scripts/run.jenkins $(JENKINS_HOST) %(dut)s $(BOARD)

hwclean:
	rm -fr obj hw vivado*.jou vivado*.log fsm_encoding.os .Xil

clean: hwclean
	rm -fr verilog
'''

androidmk_template='''
include $(CLEAR_VARS)
LOCAL_ARM_MODE := arm
APP_SRC_FILES := $(addprefix %(project_dir)s/jni/,  %(generatedCFiles)s) %(source)s
PORTAL_SRC_FILES := $(addprefix %(xbsvdir)s/cpp/, portal.c poller.cpp sock_utils.c timer.c)
LOCAL_SRC_FILES := $(APP_SRC_FILES) $(PORTAL_SRC_FILES)

LOCAL_PATH :=
LOCAL_MODULE := android_exe
LOCAL_MODULE_TAGS := optional
LOCAL_LDLIBS := -llog %(clibdirs)s %(clibs)s %(clibfiles)s
LOCAL_CPPFLAGS := "-march=armv7-a"
LOCAL_CFLAGS := -DZYNQ -I%(xbsvdir)s -I%(xbsvdir)s/cpp -I%(xbsvdir)s/lib/cpp -I%(xbsvdir)s/drivers/zynqportal -I%(project_dir)s/jni %(cincludes)s %(cdefines)s -I%(xbsvdir)s/drivers/portalmem
LOCAL_CXXFLAGS := -DZYNQ -I%(xbsvdir)s -I%(xbsvdir)s/cpp -I%(xbsvdir)s/lib/cpp -I%(xbsvdir)s/drivers/zynqportal -I%(project_dir)s/jni %(cincludes)s %(cdefines)s -I%(xbsvdir)s/drivers/portalmem

include $(BUILD_EXECUTABLE)
'''

linuxmakefile_template='''
V=0
ifeq ($(V),0)
Q=@
else
Q=
endif

CFLAGS_COMMON = -O -g -I%(project_dir)s/jni -I%(xbsvdir)s -I%(xbsvdir)s/cpp -I%(xbsvdir)s/lib/cpp %(sourceincludes)s %(cincludes)s %(cdefines)s -I%(xbsvdir)s/drivers/portalmem -I%(xbsvdir)s/drivers/pcieportal -I%(xbsvdir)s/drivers/zynqportal
CFLAGS = $(CFLAGS_COMMON)

PORTAL_CPP_FILES = $(addprefix %(xbsvdir)s/cpp/, portal.c poller.cpp sock_utils.c timer.c)
SOURCES = $(addprefix %(project_dir)s/jni/,  %(generatedCFiles)s) %(source)s $(PORTAL_CPP_FILES)
LDLIBS := %(clibdirs)s %(clibs)s -pthread 

BSIM_EXE_CXX_FILES = BsimDma.cxx BsimCtrl.cxx TlpReplay.cxx
BSIM_EXE_CXX = $(addprefix %(xbsvdir)s/cpp/, $(BSIM_EXE_CXX_FILES))

test%(classname)s: $(SOURCES)
	$(Q)g++ $(CFLAGS) -o %(classname)s $(SOURCES) $(LDLIBS)

bsim_exe: $(SOURCES)
	$(Q)g++ $(CFLAGS_COMMON) -o bsim_exe -DBSIM $(SOURCES) $(BSIM_EXE_CXX) $(LDLIBS)
'''

def preprocess(source, defs):
    
    stack = [(True,True)]

    def pp(s):
        cond  = stack[-1][0]
        valid = stack[-1][1]
        i = re.search('\n`', s)
        if i == None:
            return s
        pre = s[:i.end()-1]
        s = s[i.end():]
        j = re.search('\s', s)
        tok = s[:j.start()]
        s = s[j.end():]
        if tok == 'ifdef':
            k = re.search('\s', s)
            sym = s[:k.start()]
            s = s[k.end():]
            new_cond = sym in defs
            new_valid = new_cond and valid
            stack.append((new_cond,new_valid))
        elif tok == 'ifndef':
            k = re.search('\s', s)
            sym = s[:k.start()]
            s = s[k.end():]
            new_cond = not sym in defs
            new_valid = valid and new_cond
            stack.append((new_cond,new_valid))
        elif tok == 'else':
            new_cond = not cond
            stack.pop()
            stack.append((new_cond,valid))
        elif tok == 'endif':
            stack.pop()
        elif tok == 'define':
            k = re.search('\n', s).start()
            foo = re.search('\s',s).start()
            sym = s[:min(k,foo)]
            defs.append(sym)
            s = s[k:]
        else:
            assert(False)
        prv = pre if valid and cond else '\n\n'
        return prv+pp('\n'+s)

    return pp(source)

if __name__=='__main__':
    exename = os.path.abspath(sys.argv[0])
    xbsvdir = os.path.dirname(exename)
    options = argparser.parse_args()

    if options.verbose:
        noisyFlag = True
    if not options.export:
        sys.stderr.write('Must specify top level module name via -x/--export flag\n')
        sys.exit(-1)
    if not options.topbsv:
        sys.stderr.write('Must specify top BSV file via -t/--topbsv flag\n')
        sys.exit(-1)
    if not options.source:
        options.source = []
    if not options.bsimsource:
        options.bsimsource = []
    if not options.constraint:
        options.constraint = []
    if not options.verilog:
        options.verilog = []
    if not options.tcl:
        options.tcl = []
    if not options.xsimflags:
        options.xsimflags = ['-R']

    bscmajor = 0
    bscminor = 0
    popen = subprocess.Popen(['bsc', '-v'], stdout=subprocess.PIPE)
    m = re.match('.*version (\d+).(\d+)', popen.stdout.read())
    if m:
        bscmajor = int(m.group(1))
        bscminor = int(m.group(2))
        if noisyFlag:
            print "Using bsc %d.%d" % (bscmajor, bscminor)
    popen.terminate()

    project_dir = os.path.expanduser(options.project_dir)
    options.bsvdefine.append('project_dir=%s' % os.path.abspath(project_dir))
    srcdirs = []

    # remove intermediate files generated by parser generator
    # this is necessary due to silent failures when syntax.py is compiled
    os.path.exists('./parser.out')   and os.remove('./parser.out')
    os.path.exists('./parsetab.pyc') and os.remove('./parsetab.pyc')
    os.path.exists('./parsetab.py')  and os.remove('./parsetab.py')
    
    dutname = options.export
    boardname = options.board.lower()

    bsvdefines = options.bsvdefine
    if boardname == 'kc705':
        bsvdefines += ['Kintex7', 'PCIE']
    elif boardname == 'vc707':
        bsvdefines += ['Virtex7', 'PCIE']
    elif boardname == 'ac701':
        bsvdefines += ['Artix7',  'PCIE']
    elif boardname == 'v2000t':
        bsvdefines += ['Virtex7', 'PCIE']
    elif boardname == 'zedboard':
        bsvdefines += ['ZYNQ']
    elif boardname == 'zc702':
        bsvdefines += ['ZYNQ']
    bsvdefines += ['BOARD_'+boardname]
    if bscmajor < 2014:
        bsvdefines.append('ExportUnusedClocksAndResets')

    for inputfile in options.bsvfile:
        inputdir = os.path.dirname(inputfile)
        if not inputdir in srcdirs:
            srcdirs.append(inputdir)
        s0 = open(inputfile).read() + '\n'
        s1 = preprocess(s0, bsvdefines)
        s2 = syntax.parse(s1,inputfile, noisyFlag)

    needs_pcie_7x_gen1x8 = False
    rewireclockstring = ''
    topmodulename = dutname
    if boardname == 'kc705':
        if not 'os' in options: options.os = 'ubuntu'
        partname = 'xc7k325tffg900-2'
        needs_pcie_7x_gen1x8 = True
    elif boardname == 'vc707':
        if not 'os' in options: options.os = 'ubuntu'
        partname = 'xc7vx485tffg1761-2'
        needs_pcie_7x_gen1x8 = True
    elif boardname == 'v2000t':
        if not 'os' in options: options.os = 'ubuntu'
        partname = 'xc7v2000tflg1925-2'
        needs_pcie_7x_gen1x8 = True
    elif boardname == 'ac701':
        if not 'os' in options: options.os = 'ubuntu'
        partname = 'xc7a200tfbg676-2'
        needs_pcie_7x_gen1x8 = True
    elif boardname == 'zc706':
        if not 'os' in options: options.os = 'android'
        partname = 'xc7z045ffg900-2'
        rewireclockstring = tclzynqrewireclock
        #options.verilog.append(os.path.join(xbsvdir, 'xilinx', 'sources', 'processing_system7'))
        options.constraint.append(os.path.join(xbsvdir, 'xilinx/constraints/zc7z045ffg900.xdc'))
    elif boardname == 'zynq100':
        if not 'os' in options: options.os = 'android'
        partname = 'xc7z100ffg900-2'
        rewireclockstring = tclzynqrewireclock
        #options.verilog.append(os.path.join(xbsvdir, 'xilinx', 'sources', 'processing_system7'))
        options.constraint.append(os.path.join(xbsvdir, 'xilinx/constraints/zc7z045ffg900.xdc'))
    else:
        if not 'os' in options: options.os = 'android'
        partname = 'xc7z020clg484-1'
        rewireclockstring = tclzynqrewireclock
        options.constraint.append(os.path.join(xbsvdir, 'xilinx/constraints/zc7z020clg484.xdc'))
    options.verilog.append(os.path.join(xbsvdir, 'verilog'))

    options.constraint.append(os.path.join(xbsvdir, 'xilinx/constraints/%s.xdc' % boardname))
    #if needs_pcie_7x_gen1x8:
        #subprocess.call(['make', '-C', xbsvdir, 'xilinx/pcie_7x_gen1x8'])
        #options.xci.append(os.path.join(xbsvdir, 'xilinx', 'pcie_7x_gen1x8', 'pcie_7x_0.xci'))

    ## code generation pass
    swProxies = []
    hwProxies = []
    swWrappers = []
    hwWrappers = []

    if not options.s2hinterface:
        options.s2hinterface = []
    if not options.h2sinterface:
        options.h2sinterface = []

    for i in set(options.s2hinterface + options.h2sinterface):
        ifc = syntax.globalvars[i]
        ifc = ifc.instantiate(dict(zip(ifc.params, ifc.params)))
        ifc.ind = AST.Interface(i, [], [], None, ifc.package)
        ifc.ind.insertPutFailedMethod()
        ifc.ind.req = ifc
        ifc.assignRequestResponseChannels()
        ifc.ind.assignRequestResponseChannels()
        if i in options.s2hinterface:
            swProxies.append(ifc)
            hwWrappers.append(ifc)
        if i in options.h2sinterface:
            hwProxies.append(ifc)
            swWrappers.append(ifc)

    def create_cpp_file(name):
        fname = os.path.join(project_dir, 'jni', name)
        f = util.createDirAndOpen(fname, 'w')
        if noisyFlag:
            print "Writing file ",fname
        f.write('#include "GeneratedTypes.h"\n');
        return f

    def create_bare_file(name):
        fname = os.path.join(project_dir, 'jni', name)
        f = util.createDirAndOpen(fname, 'w')
        if noisyFlag:
            print "Writing file ",fname
        return f

    generatedCFiles = []
    hname = os.path.join(project_dir, 'jni', 'GeneratedTypes.h')
    generated_hpp = util.createDirAndOpen(hname, 'w')
    generated_hpp.write('#ifndef __GENERATED_TYPES__\n');
    generated_hpp.write('#define __GENERATED_TYPES__\n');
    generated_hpp.write('#include "portal.h"\n')
    generated_hpp.write('#ifdef __cplusplus\n')
    generated_hpp.write('extern "C" {\n')
    generated_hpp.write('#endif\n')
    # global type declarations used by interface mthods
    for v in syntax.globaldecls:
        if (v.type == 'TypeDef'):
            v.emitCDeclaration(generated_hpp, 0, '')
    generated_hpp.write('\n');
    cppname = 'GeneratedCppCallbacks.cpp'
    generated_cpp = create_cpp_file(cppname)
    generatedCFiles.append(cppname)
    generated_cpp.write('\n#ifndef NO_CPP_PORTAL_CODE\n\n')

    for i in swProxies:
        cppname = '%sProxy.c' % i.name
        hppname = '%sProxy.h' % i.name
        hpp = create_cpp_file(hppname)
        cpp = create_cpp_file(cppname)
        hpp.write('#ifndef _%(name)s_H_\n#define _%(name)s_H_\n' % {'name': i.name.upper()})
        hpp.write('#include "%s.h"' % i.parentClass("portal"))
        i.emitCProxyDeclaration(hpp, generated_hpp, "Proxy")
        i.ind.emitCWrapperImplementation(cpp, generated_hpp, "Proxy", '', False)
        i.emitCProxyImplementation(cpp, generated_hpp, "Proxy", "", False)
        hpp.write('#endif // _%(name)s_H_\n' % {'name': i.name.upper()})
        hpp.close();
        cpp.close();
        generatedCFiles.append(cppname)

    for i in swWrappers:
        cppname = '%sWrapper.c' % i.name
        hppname = '%sWrapper.h' % i.name
        hpp = create_cpp_file(hppname)
        cpp = create_cpp_file(cppname)
        hpp.write('#ifndef _%(name)s_H_\n#define _%(name)s_H_\n' % {'name': i.name.upper()})
        i.ind.emitCProxyImplementation(cpp, generated_hpp, "WrapperStatus", "", False)
        i.emitCWrapperImplementation(cpp, generated_hpp, "Wrapper", '', False)
        generated_cpp.write('\n\n/************** Start of %sWrapper CPP ***********/\n' % i.name)
        generated_cpp.write('#include "%s"' % hppname)
        i.emitCWrapperDeclaration(hpp, generated_hpp, generated_cpp, "Wrapper")
        i.emitCWrapperImplementation(generated_cpp, generated_hpp, "Wrapper", '', True)
        hpp.write('#endif // _%(name)s_H_\n' % {'name': i.name.upper()})
        hpp.close();
        cpp.close();
        generatedCFiles.append(cppname)
    
    generated_cpp.write('\n#endif //NO_CPP_PORTAL_CODE\n')
    generated_cpp.close();
    generated_hpp.write('#ifdef __cplusplus\n')
    generated_hpp.write('}\n')
    generated_hpp.write('#endif\n')
    generated_hpp.write('#endif //__GENERATED_TYPES__\n');
    generated_hpp.close();

    def create_bsv_package(pname, files=[]):
        fname = os.path.join(project_dir, 'sources', dutname.lower(), '%s.bsv' % pname)
        bsv_file = util.createDirAndOpen(fname, 'w')
        bsv_file.write('package %s;\n' % pname)
        bsvgen.emitPreamble(bsv_file, files)
        if noisyFlag:
            print 'Writing file ', fname
        return bsv_file

    def close_bsv_package(bsv_file, pname):
        bsv_file.write('endpackage: %s\n' % pname)
        bsv_file.close()

    for i in hwWrappers:
        pname = '%sWrapper' % i.name
        bsv = create_bsv_package(pname, i.package)
        i.emitBsvWrapper(bsv)
        close_bsv_package(bsv,pname)
        
    for i in hwProxies:
        pname = '%sProxy' % i.name
        bsv = create_bsv_package(pname, i.package)
        i.emitBsvProxy(bsv, "Proxy")
        close_bsv_package(bsv,pname)

    tclboardname = os.path.join(project_dir, 'board.tcl')
    tclimplname = os.path.join(project_dir, 'vivado-impl.tcl')
    tclsynthname = os.path.join(project_dir, '%s-synth.tcl' % options.export.lower())
    makename = os.path.join(project_dir, 'Makefile')
    timestampname = os.path.join(project_dir, 'sources', dutname.lower(), '.timestamp')

    androidmkname = os.path.join(project_dir, 'jni', 'Android.mk')
    linuxmkname = os.path.join(project_dir, 'jni', 'Ubuntu.mk')
 
    if os != 'android':
        xpsgen.writeImpactCmd(dutname, os.path.join(project_dir, 'impact.cmd'))
        xpsgen.writeProgramTcl(dutname, os.path.join(project_dir, '%s-program.tcl' % dutname.lower()))
        xpsgen.writeReprogramTcl(dutname, os.path.join(project_dir, '%s-reprogram.tcl' % dutname.lower()))

    if noisyFlag:
        print 'Writing Android.mk', androidmkname
    className = cppgen.cName(dutname)
    substs = {
        #android
	'generatedCFiles': ' '.join(generatedCFiles),
	'project_dir': os.path.abspath(project_dir),
        #ubuntu
        'classname': className.lower(),
        'sourceincludes': ' '.join(['-I%s' % os.path.dirname(os.path.abspath(sf)) for sf in options.source]) if options.source else '',
        #common
        'source': ' '.join([os.path.abspath(sf) for sf in options.source]) if options.source else '',
        'xbsvdir': xbsvdir,
	'clibs': ' '.join(['-l%s' % l for l in options.clib]),
	'clibfiles': ' '.join(['%s' % l for l in options.clibfiles]),
	'clibdirs': ' '.join([ '-L%s' % os.path.abspath(l) for l in options.clibdir ]),
	'cdefines': ' '.join([ '-D%s' % d for d in options.bsvdefine ]),
	'cincludes': ' '.join([ '-I%s' % os.path.abspath(i) for i in options.cinclude ])
    }
    f = util.createDirAndOpen(androidmkname, 'w')
    f.write(androidmk_template % substs)
    f.close()
    f = util.createDirAndOpen(linuxmkname, 'w')
    f.write(linuxmakefile_template % substs)
    f.close()
    if options.stl:
	    f = util.createDirAndOpen(os.path.join(project_dir, 'jni', 'Application.mk'), 'w')
	    f.write('APP_STL                 := %s\n' % options.stl)
	    f.close()

    if noisyFlag:
        print 'Writing tcl impl file', tclimplname
    tclsubsts = {'dut': topmodulename.lower(),
                 'Dut': topmodulename,
                 'rewire_clock': rewireclockstring,
                 'sourceTcl': ''.join(['source {%s}\n' % os.path.basename(tcl) for tcl in options.tcl]),
                 'project_dir': project_dir,
                 'partname': partname,
                 'boardname': boardname,
                 'xbsvdir': xbsvdir,
                 'tclfileConstraints': '\n'.join([tclfileConstraintTemplate
                                                  % { 'xdcname': os.path.basename(f) }
                                                  for f in options.constraint ]),
                 'read_verilog': '\n'.join([tclReadVerilogTemplate
                                            % { 'verilog': os.path.abspath(f),
						'pattern': '/*.v' if os.path.isdir(f) else ''} for f in options.verilog]),
                 'read_xci': '\n'.join([tclReadXciTemplate
                                        % { 'xci': f } for f in options.xci]),
                 'needspcie': 1 if needs_pcie_7x_gen1x8 else 0,
                 'tcldefines': '\n'.join(['set %s {%s}' % (var,val) for (var,val) in map(util.splitBinding, options.bsvdefine)]),
                 'ipdir': os.path.abspath(options.ipdir) if options.ipdir else xbsvdir
                 }
    tcl = util.createDirAndOpen(tclimplname, 'w')
    tcl.write(tclfileTemplate % tclsubsts)
    tcl.close()
    tcl = util.createDirAndOpen(tclboardname, 'w')
    tcl.write(tclboardTemplate % tclsubsts)
    tcl.close()

    if options.verilog and 0:
        for verilog in options.verilog:
            if noisyFlag:
                print 'Copying verilog sources from', verilog
            dstverilog = os.path.join(project_dir, 'sources', os.path.basename(verilog))
            ## this path is here so we can overwrite sources
            if os.path.exists(dstverilog):
                for f in glob.glob(os.path.join(verilog, '*')):
                    print f, os.path.basename(f)
                    dstpath = os.path.join(project_dir, 'sources', os.path.basename(verilog), os.path.basename(f))
                    if os.path.isfile(f):
                        shutil.copyfile(f, dstpath)
                    else:
                        shutil.copytree(f, dstpath)
            else:
                shutil.copytree(verilog, os.path.join(project_dir, 'sources', os.path.basename(verilog)))
    if options.constraint:
        for constraint in options.constraint:
            if noisyFlag:
                print 'Copying constraint file from', constraint
            dstconstraintdir = os.path.join(project_dir, 'constraints')
            if not os.path.exists(dstconstraintdir):
                os.makedirs(dstconstraintdir)
            ## this path is here so we can overwrite sources
            shutil.copy(constraint, dstconstraintdir)
    if options.tcl:
        for tcl in options.tcl:
            if noisyFlag:
                print 'Copying tcl file from', tcl
            ## this path is here so we can overwrite sources
            shutil.copy(tcl, project_dir)

    if noisyFlag:
        print 'Writing Makefile', makename
    make = util.createDirAndOpen(makename, 'w')
    debug_flag = ''
    if os.environ.has_key('XBSV_DEBUG'):
        debug_flag = '_debug'

    if options.partition_module:
        bitsmake=fpgamakeRuleTemplate % {'partitions': ' '.join(['-s %s' % p for p in options.partition_module]),
					 'floorplan': os.path.abspath(options.floorplan) if options.floorplan else '',
					 'xdc': ' '.join(['--xdc=%s' % os.path.abspath(xdc) for xdc in options.constraint]),
					 'xci': ' '.join(['--xci=%s' % os.path.abspath(xci) for xci in options.xci]),
					 'cachedir': '--cachedir=%s' % os.path.abspath(options.cachedir) if options.cachedir else ''
					 }
    else:
        bitsmake=bitsmakeRuleTemplate

    make.write(makefileTemplate % {'xbsvdir': xbsvdir,
                                   'bsvpath': ':'.join(list(set([os.path.dirname(os.path.abspath(bsvfile)) for bsvfile in options.bsvfile]
                                                                + [os.path.join(xbsvdir, 'bsv')]
                                                                + [os.path.join(xbsvdir, 'lib/bsv')]
                                                                + [os.path.join(xbsvdir, 'generated/xilinx')]))),
                                   'bsvdefines': util.foldl((lambda e,a: e+' -D '+a), '', bsvdefines),
                                   'boardname': boardname,
                                   'OS': options.os,
                                   'debug': debug_flag,
                                   'qtused': 'cd jni; qmake ../..; make' if options.qtused else '',
                                   's2hinterface': ' '.join(options.s2hinterface),
                                   'h2sinterface': ' '.join(options.h2sinterface),
                                   'bsvfiles': ' '.join([ os.path.abspath(bsvfile) for bsvfile in options.bsvfile]),
                                   'sourcefiles': ' '.join([os.path.abspath(source) for source in options.source]) if options.source else '',
                                   'bsimsource': ' '.join([os.path.abspath(bsimsource) for bsimsource in options.bsimsource]) if options.bsimsource else '',
                                   'generatedCFiles': ' '.join(generatedCFiles),
                                   'includepath': ' '.join(['-I%s' % os.path.dirname(os.path.abspath(source)) for source in options.source]) if options.source else '',
                                   'project_dir': os.path.abspath(project_dir),
                                   'topbsvfile' : os.path.abspath(options.topbsv),
                                   'topbsvmod'  : options.export,
                                   'dut' : options.export.lower(),
                                   'Dut': topmodulename,
                                   'timestamp' : int(time.time()),
                                   'clibs': ' '.join(['-l%s' % l for l in options.clib]),
                                   'cdefines': ' '.join([ '-D%s' % d for d in options.bsvdefine ]),
                                   'mdefines': '\n'.join(['%s="%s"' % (var,val) for (var,val) in map(util.splitBinding, options.bsvdefine)]),
                                   'bscmajor': bscmajor,
                                   'bscminor': bscminor,
                                   'bscflags': ' '.join(options.bscflags),
                                   'xelabflags': ' '.join(options.xelabflags),
                                   'xsimflags': ' '.join(options.xsimflags),
				   'bitsmake': bitsmake
                                   })
    make.close()
    #print options.xsimflags
    timestamp = util.createDirAndOpen(timestampname, 'w')
    timestamp.close()

    if options.make:
        os.chdir(project_dir)
        os.putenv('PWD', subprocess.check_output(['pwd'])[0:-1])
        subprocess.call(['make'] + options.make)
