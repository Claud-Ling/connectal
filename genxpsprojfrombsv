#!/usr/bin/python
import os, sys, shutil, string
import AST
import bsvgen
import xpsgen
import cppgen
import syntax
import argparse
import subprocess
import util
import re
import glob

AST.TypeDef.__bases__ += (cppgen.TypeDefMixin,)
AST.Function.__bases__ += (cppgen.NoCMixin,)
AST.Module.__bases__ += (cppgen.NoCMixin,)
AST.Method.__bases__ += (cppgen.MethodMixin,bsvgen.MethodMixin)
AST.StructMember.__bases__ += (cppgen.StructMemberMixin,)
AST.Struct.__bases__ += (cppgen.StructMixin,bsvgen.NullMixin)
AST.EnumElement.__bases__ += (cppgen.EnumElementMixin,)
AST.Enum.__bases__ += (cppgen.EnumMixin,bsvgen.EnumMixin)
AST.Type.__bases__ += (cppgen.TypeMixin,bsvgen.TypeMixin)
AST.Param.__bases__ += (cppgen.ParamMixin,bsvgen.ParamMixin)
AST.Interface.__bases__ += (cppgen.InterfaceMixin,bsvgen.InterfaceMixin,xpsgen.InterfaceMixin)

supported_boards = ['zedboard', 'zc702', 'kc705', 'vc707']
supported_os = ['android', 'ubuntu']

argparser = argparse.ArgumentParser("Generate C++/BSV/Xilinx stubs for an interface.")
argparser.add_argument('bsvfile', help='BSV files to parse', nargs='+')
argparser.add_argument('-B', '--board', default='zc702', choices=supported_boards,
                       help='Board to generate stubs and ucf constraints for')
argparser.add_argument('-O', '--OS', default=None, choices=supported_os,
                       help='Target operating system')
argparser.add_argument('-s2h', '--s2hinterface', help='BSV interface to generate stubs for software to hardware communication', action='append')
argparser.add_argument('-h2s', '--h2sinterface', help='BSV interface to generate stubs for hardware to software communication', action='append')
argparser.add_argument('-p', '--project-dir', default='./xpsproj', help='xps project directory')
argparser.add_argument('-e', '--edk-version', default=xpsgen.edkversion, help='Xilinx EDK version', choices=xpsgen.edkversions)
argparser.add_argument('-c', '--coherent', help='Use ACP coherence port for first AXI master bus')
argparser.add_argument('-s', '--source', help='C++ source files', action='append')
argparser.add_argument('-I', '--contentid', help='Specify 64-bit contentid for PCIe designs')
argparser.add_argument('-V', '--verilog', help='Additional verilog sources', action='append')
argparser.add_argument('-C', '--constraint', help='Additional constraint files', action='append')
argparser.add_argument('-M', '--make', help='Run make on the specified targets', action='append')
argparser.add_argument('-x', '--export', help='Promote/export named interface from top module')


tclfileXprTemplate='''
create_project %(dut)s . -part %(partname)s
add_files sources
%(tclfileAdditionalConstraints)s
add_files -fileset constrs_1 -norecurse {constraints/%(dut)s.xdc}
update_compile_order -fileset sources_1
update_compile_order -fileset sources_1
update_compile_order -fileset sim_1
close_project
'''

tclfileAdditionalConstraintTemplate='''add_files -fileset constrs_1 -norecurse {constraints/%(xdcname)s}'''

tclfileTemplate='''
open_project %(dut)s
reset_run synth_1
reset_run impl_1
set_property strategy manual_fsm [get_runs synth_1]
launch_runs synth_1
wait_on_run synth_1
launch_runs impl_1
wait_on_run impl_1
## causes it to create both .bit and .bin files
set_property STEPS.WRITE_BITSTREAM.ARGS.BIN_FILE true [get_runs impl_1]
launch_runs impl_1 -to_step write_bitstream
wait_on_run impl_1
close_project
'''

makefileTemplate='''
DTOP=%(project_dir)s
XBSVTOP=%(xbsvdir)s
BSVPATH = %(bsvpath)s
vfile=sources/%(dut)s/mk%(Top)s.v

BOARD=%(boardname)s
OS=%(OS)s
ifeq ($(OS),android)
ALLTARGETS=bits exe
else
ALLTARGETS=implementation ubuntu_exe
endif

BSCFLAGS=--aggressive-conditions --wait-for-license -show-schedule -bdir $(DTOP)/obj

all: $(ALLTARGETS)

$(vfile): sources/%(dut)s/%(Top)s.bsv %(bsvfiles)s
	mkdir -p $(DTOP)/obj
	cd sources/%(dut)s; bsc %(bsvdefines)s $(BSCFLAGS) -p +:$(BSVPATH) -verilog -u -g mk%(Top)s %(Top)s.bsv
	$(XBSVTOP)/scripts/copy_verilog.py $(vfile) $(subst :, ,$(BSVPATH))

x86_exe: jni/*.cpp jni/*.cxx %(sourcefiles)s
	cd jni; g++ -g -O -o %(dut)s -I%(project_dir)s/jni %(includepath)s *.cpp *.cxx %(sourcefiles)s -pthread -I$(XBSVTOP) -I$(XBSVTOP)/cpp -DBSIM 

ubuntu_exe:
	cd jni; make

bsim:
	mkdir -p $(DTOP)/obj
	cd sources; bsc -D BSIM %(bsvdefines)s $(BSCFLAGS) -simdir . -p +:$(BSVPATH):%(dut)s/ -sim -u -g mkBsimTop BsimTop.bsv 
	export BSC_CXXFLAGS="-I$(XBSVTOP)/cpp -I$(XBSVTOP) -DBSIM" ; cd sources; bsc $(BSCFLAGS) -simdir . -p +:$(BSVPATH):%(dut)s/ -sim -e mkBsimTop -o bsim $(DTOP)/obj/*.ba $(XBSVTOP)/cpp/BsimTop.cxx $(XBSVTOP)/cpp/BsimDMA.cxx $(XBSVTOP)/cpp/sock_utils.cxx $(XBSVTOP)/cpp/sock_fd.cxx

verilog: $(vfile)

lint: $(vfile)
	verilator --error-limit 200 --lint-only -Isources/%(dut)s -Isources/source $(vfile)

%(dut)s.xpr:
	vivado -mode batch -source %(dut)sxpr.tcl

%(dut)s.runs/impl_1/%(dut)s_top_1.bit: $(vfile) %(dut)s.xpr
	vivado -mode batch -source %(dut)s.tcl

implementation: %(dut)s.runs/impl_1/%(dut)s_top_1.bit

program:
	vivado -mode batch -source %(dut)s-program.tcl

%(dut)s.bit.bin.gz: %(dut)s.runs/impl_1/%(dut)s_top_1.bit
	#promgen -w -b -p bin -o %(dut)s.bit.bin -u 0 %(dut)s.runs/impl_1/%(dut)s_top_1.bit -data_width 32
	xxd %(dut)s.runs/impl_1/%(dut)s_top_1.bin | sed -e "s/  .*//" -e "s/ \(..\)\(..\) \(..\)\(..\)/ \\4\\3 \\2\\1/g" | xxd -r >%(dut)s.bit.bin
	gzip -f %(dut)s.bit.bin

bits: %(dut)s.bit.bin.gz
boot.bin: %(dut)s.bit.bin.gz

exe:
	ndk-build
'''

vivado_strategies={
    'manual_fsm.Vivado Synthesis 2013.psg':
'''<?xml version="1.0"?>
<Strategy Version="1" Minor="2">
	<StratHandle Name="manual_fsm" Flow="Vivado Synthesis 2013">
	</StratHandle>
	<Step Id="synth_design">
		<Option Id="FsmExtraction">0</Option>
	</Step>
</Strategy>
'''
}

def preprocess(source, defs):
    
    stack = [(True,True)]

    def pp(s):
        cond  = stack[-1][0]
        valid = stack[-1][1]
        i = re.search('\n`', s)
        if i == None:
            return s
        pre = s[:i.end()-1]
        s = s[i.end():]
        j = re.search('\s', s)
        tok = s[:j.start()]
        s = s[j.end():]
        if tok == 'ifdef':
            k = re.search('\s', s)
            sym = s[:k.start()]
            s = s[k.end():]
            new_cond = sym in defs
            new_valid = new_cond and valid
            stack.append((new_cond,new_valid))
        elif tok == 'ifndef':
            k = re.search('\s', s)
            sym = s[:k.start()]
            s = s[k.end():]
            new_cond = not sym in defs
            new_valid = valid and new_cond
            stack.append((new_cond,new_valid))
        elif tok == 'else':
            new_cond = not cond
            stack.pop()
            stack.append((new_cond,valid))
        elif tok == 'endif':
            stack.pop()
        else:
            assert(false)
        prv = pre if valid and cond else '\n\n'
        return prv+pp('\n'+s)

    return pp(source)

def write_vivado_strategies():
    stratdir = os.path.join(os.environ['HOME'], '.Xilinx', 'Vivado', 'strategies')
    if not os.path.exists(stratdir):
        os.makedirs(stratdir)
    for k in vivado_strategies:
        print 'Writing vivado strategy file', k, ' to directory ', stratdir
        f = open(os.path.join(stratdir, k), 'w')
        f.write(vivado_strategies[k])
        f.close()    

if __name__=='__main__':
    exename = os.path.abspath(sys.argv[0])
    xbsvdir = os.path.dirname(exename)
    namespace = argparser.parse_args()

    write_vivado_strategies()
    project_dir = os.path.expanduser(namespace.project_dir)
    srcdirs = []

    # remove intermediate files generated by parser generator
    # this is necessary due to silent failures when syntax.py is compiled
    os.path.exists('./parser.out')   and os.remove('./parser.out')
    os.path.exists('./parsetab.pyc') and os.remove('./parsetab.pyc')
    os.path.exists('./parsetab.py')  and os.remove('./parsetab.py')
    
    dutname = namespace.export
    corename = '%s_v1_00_a' % dutname
    boardname = namespace.board.lower()

    bsvdefines = ['BSIM'] if namespace.make and ('bsim' in namespace.make) else []
    if boardname == 'kc705':
        bsvdefines += ['Kintex7']
    elif boardname == 'vc707':
        bsvdefines += ['Virtex7']
    
    for inputfile in namespace.bsvfile:
        inputdir = os.path.dirname(inputfile)
        if not inputdir in srcdirs:
            srcdirs.append(inputdir)
        s0 = open(inputfile).read() + '\n'
        s1 = preprocess(s0, bsvdefines)
        s2 = syntax.parse(s1)

    if namespace.coherent:
        xpsgen.use_acp = 1
        print 'Using ACP for coherent memory access'

    needs_pcie_7x_v2_1 = False
    if not namespace.constraint:
        namespace.constraint = []
    if not namespace.verilog:
        namespace.verilog = []
    if boardname == 'kc705':
        if not 'os' in namespace: namespace.os = 'ubuntu'
        partname = 'xc7k325tffg900-2'
        topSuffix = 'PcieTop'
        needs_pcie_7x_v2_1 = True
        namespace.verilog.append(os.path.join(xbsvdir, 'xilinx', 'pcie_7x_v2_1', 'pcie_7x_0', 'source'))
        namespace.verilog.append(os.path.join(xbsvdir, 'xilinx', '7x', 'pcie', 'source'))
        namespace.constraint.append(os.path.join(xbsvdir, 'xilinx/constraints/kc705.xdc'))
    elif boardname == 'vc707':
        if not 'os' in namespace: namespace.os = 'ubuntu'
        partname = 'xc7vx485tffg1761-2'
        topSuffix = 'PcieTop'
        needs_pcie_7x_v2_1 = True
        namespace.verilog.append(os.path.join(xbsvdir, 'xilinx', 'pcie_7x_v2_1', 'pcie_7x_0', 'source'))
        namespace.verilog.append(os.path.join(xbsvdir, 'xilinx', '7x', 'pcie', 'source'))
        namespace.constraint.append(os.path.join(xbsvdir, 'xilinx/constraints/vc707.xdc'))
    else:
        if not 'os' in namespace: namespace.os = 'android'
        partname = 'xc7z020clg484-1'
        topSuffix = 'Wrapper'
        namespace.verilog.append(os.path.join(xbsvdir, 'xilinx', 'sources', 'processing_system7'))
        namespace.constraint.append(os.path.join(xbsvdir, 'xilinx/constraints/design_1_processing_system7_1_0.xdc'))

    if needs_pcie_7x_v2_1:
        subprocess.call(['make', '-C', xbsvdir, 'xilinx/pcie_7x_v2_1'])

    # this is an ugly abuse of typeclassinstance
    for v in syntax.globaldecls:
        if (v.type == 'TypeclassInstance' and v.name == 'PortalMemory'):
            assert (len(v.params) == 1)
            syntax.globalvars[v.params[0].name].typeClassInstances.append(v.name)

    ## code generation pass
    swProxies = []
    hwProxies = []
    swWrappers = []
    hwWrappers = []

    for i in set(namespace.s2hinterface + namespace.h2sinterface):
        ifc = syntax.globalvars[i]
        ifc = ifc.instantiate(dict(zip(ifc.params, ifc.params)))
        ifc.ind = AST.Interface(i, [], [], None)
        ifc.ind.insertPutErrorMethod()
        ifc.ind.req = ifc
        ifc.assignRequestResponseChannels()
        ifc.ind.assignRequestResponseChannels()
        if i in namespace.s2hinterface:
            swProxies.append(ifc)
            hwWrappers.append(ifc)
        if i in namespace.h2sinterface:
            hwProxies.append(ifc)
            swWrappers.append(ifc)

    def create_cpp_file(name):
        fname = os.path.join(project_dir, 'jni', name)
        f = util.createDirAndOpen(fname, 'w')
        print "Writing file ",fname
        return f

    for i in swProxies:
        hpp = create_cpp_file('%sProxy.h' % i.name)
        cpp = create_cpp_file('%sProxy.cpp' % i.name)
        i.ind.emitCWrapperDeclaration(hpp, "ProxyStatus")
        i.emitCProxyDeclaration(hpp, "Proxy")
        i.ind.emitCWrapperImplementation(cpp, "ProxyStatus")
        i.emitCProxyImplementation(cpp, "Proxy")
        hpp.close();
        cpp.close();

    for i in swWrappers:
        hpp = create_cpp_file('%sWrapper.h' % i.name)
        cpp = create_cpp_file('%sWrapper.cpp' % i.name)
        i.ind.emitCProxyDeclaration(hpp, "WrapperStatus")
        i.emitCWrapperDeclaration(hpp, "Wrapper")
        i.ind.emitCProxyImplementation(cpp, "WrapperStatus")
        i.emitCWrapperImplementation(cpp, "Wrapper")
        hpp.close();
        cpp.close();
    
    hname = os.path.join(project_dir, 'jni', 'GeneratedTypes.h')
    hpp = util.createDirAndOpen(hname, 'w')
    # global type declarations used by interface mthods
    for v in syntax.globaldecls:
        if (v.type == 'TypeDef') and v.tdtype.type == 'Struct':
            v.emitCDeclaration(hpp)
    hpp.close();
    cpp.close();

    def create_bsv_package(pname, files=[]):
        fname = os.path.join(project_dir, 'sources', dutname, '%s.bsv' % pname)
        bsv_file = util.createDirAndOpen(fname, 'w')
        bsv_file.write('package %s;\n' % pname)
        bsvgen.emitPreamble(bsv_file, namespace.bsvfile+files)
        print 'Writing file ', fname
        return bsv_file

    def close_bsv_package(bsv_file, pname):
        bsv_file.write('endpackage: %s\n' % pname)
        bsv_file.close()

    for i in hwWrappers:
        pname = '%sWrapper' % i.name
        bsv = create_bsv_package(pname)
        i.ind.emitBsvProxy(bsv, "WrapperStatus", False)
        i.emitBsvWrapper(bsv, "Wrapper", True)
        close_bsv_package(bsv,pname)
        
    for i in hwProxies:
        pname = '%sProxy' % i.name
        bsv = create_bsv_package(pname)
        i.ind.emitBsvWrapper(bsv, "ProxyStatus",False)
        i.emitBsvProxy(bsv, "Proxy",True)
        close_bsv_package(bsv,pname)
        
    assert(False)

    if (boardname == 'kc705' or boardname == 'vc707'):
        pcie_name = os.path.join(project_dir, 'sources', namespace.interface.lower(),
                                 '%sPcieTop.bsv' % util.capitalize(namespace.interface))
        topRequestIfc.writeProjectBld(project_dir, srcdirs)
    else: # Zynq platform
        topRequestIfc.writeTopVerilog(topverilogname)
        topRequestIfc.writeXdc(xdcname, boardname)

    if os != 'android':
        topRequestIfc.writeImpactCmd(os.path.join(project_dir, 'impact.cmd'))
        topRequestIfc.writeProgramTcl(os.path.join(project_dir, '%s-program.tcl' % namespace.interface.lower()))
    print 'Writing Android.mk', androidmkname
    print 'Writing Application.mk', applicationmkname
    topRequestIfc.writeAndroidMk(androidmkname, applicationmkname)
    topRequestIfc.writeLinuxMk(linuxmkname, xbsvdir, namespace.source)

    assert(False);

    tclname = os.path.join(project_dir, '%s.tcl' % namespace.export.lower())
    tclxprname = os.path.join(project_dir, '%sxpr.tcl' % namespace.export.lower())
    makename = os.path.join(project_dir, 'Makefile')

    applicationmkname = os.path.join(project_dir, 'jni', 'Application.mk')
    androidmkname = os.path.join(project_dir, 'jni', 'Android.mk')
    linuxmkname = os.path.join(project_dir, 'jni', 'Makefile')
    
    topverilogname = os.path.join(project_dir, 'sources', 'top.v')
    ucfname = os.path.join(project_dir, 'data',
                           '%s.ucf' % dutname)
    xdcname = os.path.join(project_dir, 'constraints',
                           '%s.xdc' % dutname)


    print 'Writing tcl file', tclname
    tcl = util.createDirAndOpen(tclname, 'w')
    tcl.write(tclfileTemplate % {'dut': namespace.interface.lower(),
                                 'Dut': util.capitalize(namespace.interface),
                                 'project_dir': project_dir
                                 })
    tcl.close()
    tcl = util.createDirAndOpen(tclxprname, 'w')
    tcl.write(tclfileXprTemplate % {'dut': namespace.interface.lower(),
                                    'Dut': util.capitalize(namespace.interface),
                                    'partname': partname,
                                    'project_dir': project_dir,
                                    'tclfileAdditionalConstraints': '\n'.join([tclfileAdditionalConstraintTemplate
                                                                               % { 'xdcname': os.path.basename(f) }
                                                                               for f in namespace.constraint ])
                                    })
    tcl.close()

    if namespace.verilog:
        for verilog in namespace.verilog:
            print 'Copying verilog sources from', verilog
            dstverilog = os.path.join(project_dir, 'sources', os.path.basename(verilog))
            ## this path is here so we can overwrite sources
            if os.path.exists(dstverilog):
                for f in glob.glob(os.path.join(verilog, '*')):
                    print f, os.path.basename(f)
                    dstpath = os.path.join(project_dir, 'sources', os.path.basename(verilog), os.path.basename(f))
                    if os.path.isfile(f):
                        shutil.copyfile(f, dstpath)
                    else:
                        shutil.copytree(f, dstpath)
            else:
                shutil.copytree(verilog, os.path.join(project_dir, 'sources', os.path.basename(verilog)))
    if namespace.constraint:
        for constraint in namespace.constraint:
            print 'Copying constraint file from', constraint
            dstconstraintdir = os.path.join(project_dir, 'constraints')
            if not os.path.exists(dstconstraintdir):
                os.makedirs(dstconstraintdir)
            ## this path is here so we can overwrite sources
            shutil.copy(constraint, dstconstraintdir)
    print 'Writing Makefile', makename
    make = util.createDirAndOpen(makename, 'w')
    make.write(makefileTemplate % {'corename': corename,
                                   'dut': namespace.interface.lower(),
                                   'Dut': util.capitalize(namespace.interface),
                                   'Top': '%s%s' % (util.capitalize(namespace.interface), topSuffix),
                                   'xbsvdir': xbsvdir,
                                   'bsvpath': ':'.join(list(set([os.path.dirname(os.path.abspath(bsvfile)) for bsvfile in namespace.bsvfile]
                                                                + [os.path.join(xbsvdir, 'bsv')]))),
                                   'bsvname': os.path.basename(namespace.bsvfile[0]),
                                   'bsvdefines': util.foldl((lambda e,a: '-D '+e+' '+a), '', bsvdefines),
                                   'boardname': boardname,
                                   'OS': namespace.os,
                                   'bsvfiles': ' '.join([ os.path.abspath(bsvfile) for bsvfile in namespace.bsvfile]),
                                   'sourcefiles': ' '.join([os.path.abspath(source) for source in namespace.source]) if namespace.source else '',
                                   'includepath': ' '.join(['-I%s' % os.path.dirname(os.path.abspath(source)) for source in namespace.source]) if namespace.source else '',
                                   'project_dir': os.path.abspath(project_dir)
                                   })
    make.close()

    print '############################################################'
    print '## To build:'
    print '    cd %s; make verilog; make bits' % (project_dir)
    print '## You can use XPS to generate bit file or exit and let make complete the process.'

    if namespace.make:
        os.chdir(project_dir)
        os.putenv('PWD', subprocess.check_output(['pwd'])[0:-1])
        subprocess.call(['make'] + namespace.make)
