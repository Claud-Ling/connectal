#!/usr/bin/python
import os, sys, shutil, string
import AST
import bsvgen
import xpsgen
import cppgen
import syntax
import argparse
import subprocess
import util
import re

AST.Function.__bases__ += (cppgen.NoCMixin,)
AST.Module.__bases__ += (cppgen.NoCMixin,)
AST.Method.__bases__ += (cppgen.MethodMixin,bsvgen.MethodMixin)
AST.StructMember.__bases__ += (cppgen.StructMemberMixin,)
AST.Struct.__bases__ += (cppgen.StructMixin,bsvgen.NullMixin)
AST.EnumElement.__bases__ += (cppgen.EnumElementMixin,)
AST.Enum.__bases__ += (cppgen.EnumMixin,bsvgen.NullMixin)
AST.Type.__bases__ += (cppgen.TypeMixin,bsvgen.TypeMixin)
AST.Param.__bases__ += (cppgen.ParamMixin,bsvgen.ParamMixin)
AST.Interface.__bases__ += (cppgen.InterfaceMixin,bsvgen.InterfaceMixin,xpsgen.InterfaceMixin)

supported_boards = ['zedboard', 'zc702']

requestIfcs = []
indicationIfcs = []

argparser = argparse.ArgumentParser("Generate C++/BSV/Xilinx stubs for an interface.")
argparser.add_argument('bsvfile', help='BSV files to parse', nargs='+')
argparser.add_argument('-B', '--board', default='zc702', choices=supported_boards,
                       help='Board to generate stubs and ucf constraints for')
argparser.add_argument('-b', '--interface', help='BSV interface to generate stubs for')
argparser.add_argument('-p', '--project-dir', default='./xpsproj', help='xps project directory')
argparser.add_argument('-e', '--edk-version', default=xpsgen.edkversion, help='Xilinx EDK version', choices=xpsgen.edkversions)
argparser.add_argument('-C', '--coherent', help='Use ACP coherence port for first AXI master bus')
argparser.add_argument('-V', '--verilog', help='Additional verilog sources', nargs='+')
argparser.add_argument('-M', '--make', help='Run make on the specified targets', nargs='+')

tclfileXprTemplate='''
create_project %(dut)s . -part xc7z020clg484-1
add_files sources
add_files -fileset constrs_1 -norecurse {constraints/design_1_processing_system7_1_0.xdc}
add_files -fileset constrs_1 -norecurse {constraints/%(dut)s.xdc}
update_compile_order -fileset sources_1
update_compile_order -fileset sources_1
update_compile_order -fileset sim_1
close_project
'''

tclfileTemplate='''
open_project %(dut)s
reset_run synth_1
reset_run impl_1
set_property strategy manual_fsm [get_runs synth_1]
launch_runs synth_1
wait_on_run synth_1
launch_runs impl_1
wait_on_run impl_1
## causes it to create both .bit and .bin files
set_property STEPS.WRITE_BITSTREAM.ARGS.BIN_FILE true [get_runs impl_1]
launch_runs impl_1 -to_step write_bitstream
wait_on_run impl_1
close_project
'''

makefileTemplate='''
XBSVTOP=$(PWD)/..
BSVPATH = $(XBSVTOP)/%(bsvpath)s:$(XBSVTOP)/bsv
vfile=sources/%(dut)s/mk%(Dut)sWrapper.v

all: bits exe

$(vfile): sources/%(dut)s/%(Dut)sWrapper.bsv
	cd sources/%(dut)s; bsc --aggressive-conditions --wait-for-license -show-schedule -p +:$(BSVPATH) -verilog -u -g mk%(Dut)sWrapper %(Dut)sWrapper.bsv
	./updatepao $(vfile) $(paofile) $(subst :, ,$(BSVPATH))
	cp -r ../xilinx/sources/* sources/
	cp -r ../xilinx/constraints .

x86_exe:
	cd jni; g++ *.cpp

bsim: x86_exe
	cd sources; bsc --aggressive-conditions --wait-for-license -show-schedule -simdir . -p +:$(BSVPATH):%(dut)s/ -sim -u -g mkBsimTop BsimTop.bsv
	cd sources; bsc --aggressive-conditions --wait-for-license -show-schedule -simdir . -p +:$(BSVPATH):%(dut)s/ -sim -e mkBsimTop -o bsim *.ba $(XBSVTOP)/cpp/BsimTop.cxx

verilog: $(vfile)

%(dut)s.xpr:
	vivado -mode batch -source %(dut)sxpr.tcl

%(dut)s.runs/impl_1/%(dut)s_top_1.bit: $(vfile) sources/top.v %(dut)s.xpr
	vivado -mode batch -source %(dut)s.tcl

implementation: %(dut)s.runs/impl_1/%(dut)s_top_1.bit

%(dut)s.bit.bin.gz: %(dut)s.runs/impl_1/%(dut)s_top_1.bit
	#promgen -w -b -p bin -o %(dut)s.bit.bin -u 0 %(dut)s.runs/impl_1/%(dut)s_top_1.bit -data_width 32
	xxd %(dut)s.runs/impl_1/%(dut)s_top_1.bin | sed -e "s/  .*//" -e "s/ \(..\)\(..\) \(..\)\(..\)/ \\4\\3 \\2\\1/g" | xxd -r >%(dut)s.bit.bin
	gzip -f %(dut)s.bit.bin

bits: %(dut)s.bit.bin.gz
boot.bin: %(dut)s.bit.bin.gz

exe:
	ndk-build
'''

vivado_strategies={
    'manual_fsm.Vivado Synthesis 2013.psg':
'''<?xml version="1.0"?>
<Strategy Version="1" Minor="2">
	<StratHandle Name="manual_fsm" Flow="Vivado Synthesis 2013">
	</StratHandle>
	<Step Id="synth_design">
		<Option Id="FsmExtraction">0</Option>
	</Step>
</Strategy>
'''
}

def write_vivado_strategies():
    stratdir = os.path.join(os.environ['HOME'], '.Xilinx', 'Vivado', 'strategies')
    if not os.path.exists(stratdir):
        os.makedirs(stratdir)
    for k in vivado_strategies:
        print 'Writing vivado strategy file', k, ' to directory ', stratdir
        f = open(os.path.join(stratdir, k), 'w')
        f.write(vivado_strategies[k])
        f.close()    

if __name__=='__main__':
    namespace = argparser.parse_args()
    print namespace

    write_vivado_strategies()
    project_dir = os.path.expanduser(namespace.project_dir)

    for inputfile in namespace.bsvfile:
        s = open(inputfile).read() + '\n'
        s1 = syntax.parse(s)

    if namespace.coherent:
        xpsgen.use_acp = 1
        print 'Using ACP for coherent memory access'

    dutname = namespace.interface.lower()
    corename = '%s_v1_00_a' % namespace.interface.lower()
    boardname = namespace.board.lower()

    tclname = os.path.join(project_dir, '%s.tcl' % namespace.interface.lower())
    tclxprname = os.path.join(project_dir, '%sxpr.tcl' % namespace.interface.lower())
    makename = os.path.join(project_dir, 'Makefile')

    applicationmkname = os.path.join(project_dir, 'jni', 'Application.mk')
    androidmkname = os.path.join(project_dir, 'jni', 'Android.mk')
    hname = os.path.join(project_dir, 'jni', '%s.h' % namespace.interface)
    cppname = os.path.join(project_dir, 'jni', '%s.cpp' % namespace.interface)
    topverilogname = os.path.join(project_dir, 'sources', 'top.v')
    ucfname = os.path.join(project_dir, 'data',
                           '%s.ucf' % dutname)
    xdcname = os.path.join(project_dir, 'constraints',
                           '%s.xdc' % dutname)
    print 'Writing CPP header', hname
    h = util.createDirAndOpen(hname, 'w')
    h.write('#include "portal.h"\n')
    print 'Writing CPP wrapper', cppname
    cpp = util.createDirAndOpen(cppname, 'w')
    cpp.write('#include "%s.h"\n' % namespace.interface)
    cpp.write('#include <stdio.h>\n')
    cpp.write('#include <stdlib.h>\n')
    cpp.write('#include <assert.h>\n')


    ## code generation pass
    for v in syntax.globaldecls:
        if v.type == 'Struct':
            v.emitCDeclaration(h)
        #v.emitCImplementation(cpp)

    def create_bsv_package(pname, files=[]):
        fname = os.path.join(project_dir, 'sources', dutname, '%s.bsv' % pname)
        bsv_file = util.createDirAndOpen(fname, 'w')
        bsv_file.write('package %s;\n' % pname)
        bsvgen.emitPreamble(bsv_file, namespace.bsvfile+files)
        print 'Writing bsv file ', fname
        return bsv_file

    def close_bsv_package(bsv_file, pname):
        bsv_file.write('endpackage: %s' % pname)
        bsv_file.close()

    topRequestIfcName = '%sRequest' % util.capitalize(namespace.interface)
    topIndicationIfcName = '%sIndication' % util.capitalize(namespace.interface)

    if (syntax.globalvars.has_key(topRequestIfcName)):
        topRequestIfc = syntax.globalvars[topRequestIfcName]
        topIndicationIfc = syntax.globalvars[topIndicationIfcName]
        topRequestIfc.isIndication = False
        topIndicationIfc.isIndication = True
        topRequestIfc.top = True
        topIndicationIfc.top = True
        topRequestIfc.ind = topIndicationIfc
        topRequestIfc.base = namespace.interface

        # this is a primitive way of detecting the subinterfaces
        # which will be assigned their own request interface.  In 
        # the future I will add code which examines the actual type
        for d in topRequestIfc.decls:
            if d.type == 'Interface':
                if syntax.globalvars.has_key(d.name):
                    subintdef = syntax.globalvars[d.name]
                    newint = subintdef.instantiate(dict(zip(subintdef.params, d.params)))
                    newint.top = False
                    newint.isIndication = False
                    requestIfcs.append(newint)

        # same comment as above
        for d in topIndicationIfc.decls:
            if d.type == 'Interface':
                if syntax.globalvars.has_key(d.name):
                    subintdef = syntax.globalvars[d.name]
                    newint = subintdef.instantiate(dict(zip(subintdef.params, d.params)))
                    newint.top = False
                    newint.isIndication = True
                    indicationIfcs.append(newint)

        # find the corresponding indication interafce.  we are currently relying
        # on a naming convention, but we might relax this at some point
        assert(len(indicationIfcs) == len(requestIfcs))
        for d0 in requestIfcs:
            base = re.sub('Request', '', d0.name)
            for d1 in indicationIfcs:
                if d1.name == ('%sIndication' % base ):
                    d0.ind = d1
                    break

        wrapper_files = []
        portalNum = 0;
        for d in requestIfcs:
            # adding an error reporting channel to the indication interface for reporting 'put' errors
            d.ind.insertPutErrorMethod();
            # assign the indication methods to the lower channel numbers
            d.assignRequestResponseChannels()
            d.ind.assignRequestResponseChannels()
            
            d.portalNum = portalNum
            d.ind.portalNum = portalNum
            portalNum = portalNum+1
            
            d.ind.emitCDeclaration(h)
            d.emitCDeclaration(h)
            d.ind.emitCImplementation(cpp)
            d.emitCImplementation(cpp)            
            
            ind_pname = '%sWrapper' % d.ind.name
            ind_wrapper_file = create_bsv_package(ind_pname)
            d.ind.emitBsvImplementation(ind_wrapper_file)
            close_bsv_package(ind_wrapper_file, ind_pname)
            wrapper_files.append('%s.bsv' % ind_pname)

            req_pname = '%sWrapper' % d.name
            rec_wrapper_file = create_bsv_package(req_pname, ['%s.bsv' % ind_pname])
            d.emitBsvImplementation(rec_wrapper_file)
            close_bsv_package(rec_wrapper_file, req_pname)
            wrapper_files.append('%s.bsv' % req_pname)

        top_pname = '%sWrapper' % util.capitalize(namespace.interface)
        top_bsv_file = create_bsv_package(top_pname, wrapper_files)
        topRequestIfc.numPortals = portalNum
        topRequestIfc.writeTopBsv(top_bsv_file)
        close_bsv_package(top_bsv_file, top_pname)

        bsim_name = os.path.join(project_dir, 'sources', 'BsimTop.bsv')
        topRequestIfc.writeBsimTop(bsim_name)
        topRequestIfc.writeTopVerilog(topverilogname)
        topRequestIfc.writeUcf(ucfname, boardname)
        topRequestIfc.writeXdc(xdcname, boardname)
        print 'Writing Android.mk', androidmkname
        print 'Writing Application.mk', applicationmkname
        topRequestIfc.writeAndroidMk(androidmkname, applicationmkname)
    else:
        print 'No %s interface found' % topRequestIfcName
    h.close()
    cpp.close()

    if cppname:
        srcdir = os.path.join(os.path.dirname(sys.argv[0]), 'cpp')
        dstdir = os.path.dirname(cppname)
        for f in ['portal.h', 'portal.cpp']:
            shutil.copyfile(os.path.join(srcdir, f), os.path.join(dstdir, f))
    shutil.copyfile(os.path.join(os.path.dirname(sys.argv[0]), 'updatepao'),
                    os.path.join(project_dir, 'updatepao'))
    shutil.copymode(os.path.join(os.path.dirname(sys.argv[0]), 'updatepao'),
                    os.path.join(project_dir, 'updatepao'))

    print 'Writing tcl file', tclname
    tcl = util.createDirAndOpen(tclname, 'w')
    tcl.write(tclfileTemplate % {'dut': namespace.interface.lower(),
                                 'Dut': util.capitalize(namespace.interface),
                                 'project_dir': project_dir
                                 })
    tcl.close()
    tcl = util.createDirAndOpen(tclxprname, 'w')
    tcl.write(tclfileXprTemplate % {'dut': namespace.interface.lower(),
                                    'Dut': util.capitalize(namespace.interface),
                                    'project_dir': project_dir
                                    })
    tcl.close()

    if namespace.verilog:
        for verilog in namespace.verilog:
            print verilog
            shutil.rmtree(os.path.join(project_dir, 'sources', os.path.basename(verilog)), ignore_errors=True)
            shutil.copytree(verilog, os.path.join(project_dir, 'sources', os.path.basename(verilog)))
    print 'Writing Makefile', makename
    make = util.createDirAndOpen(makename, 'w')
    make.write(makefileTemplate % {'corename': corename,
                                   'dut': namespace.interface.lower(),
                                   'Dut': util.capitalize(namespace.interface),
                                   'bsvpath': os.path.dirname(namespace.bsvfile[0]),
                                   'bsvname': os.path.basename(namespace.bsvfile[0])
                                   })
    make.close()

    print '############################################################'
    print '## To build:'
    print '    cd %s; make verilog; make bits' % (project_dir)
    print '## You can use XPS to generate bit file or exit and let make complete the process.'

    if namespace.make:
        os.chdir(project_dir)
        os.putenv('PWD', subprocess.check_output(['pwd'])[0:-1])
        subprocess.call(['make'] + namespace.make)
